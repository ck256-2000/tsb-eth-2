// SPDX-License-Identifier: MIT

// 06/08/2023 - This code works but needs to have the randomness put back on.
//                      TRILLION SHIB BURN 2023
//      ▀█▀ █▀█ █ █░░ █░░ █ █▀█ █▄░█   █▀ █░█ █ █▄▄   █▄▄ █░█ █▀█ █▄░█
//      ░█░ █▀▄ █ █▄▄ █▄▄ █ █▄█ █░▀█   ▄█ █▀█ █ █▄█   █▄█ █▄█ █▀▄ █░▀█
//
//
//                      ⠀⠀⢀⡶⠛⠛⢦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⡶⠛⠛⣦⡀⠀⠀
//                      ⠀⠀⣸⠃⠀⠀⠀⠙⢷⣴⣶⣿⣿⣿⣿⣿⣿⣿⣷⣶⣦⡾⠋⠀⠀⠀⢸⡇⠀⠀
//                      ⠀⠀⣿⠀⠀⠀⠀⠀⠀⠙⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀⠀⠈⣇⠀⠀
//                      ⠀⠀⣿⠀⠀⠀⠀⠀⠀⠀⠈⠉⠁⠀⠀⠀⠀⠉⠉⠁⠀⠀⠀⠀⠀⠀⢠⡇⠀⠀
//                      ⠀⠀⣼⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣧⠀⠀
//                      ⠀⣼⣿⣿⡀⠀⠀⠀⢀⣠⣀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣄⡀⠀⠀⠀⢠⣿⣿⣧⠀
//                      ⢸⣿⣿⣿⠃⠀⠀⠀⠘⠿⠿⠂⠀⠀⠀⠀⠀⠀⠸⠿⠿⠃⠀⠀⠀⠹⣿⣿⣿⡆
//                      ⣿⣿⣿⡏⠀⠀⠀⠀⣿⣷⣦⡀⠀⠀⠀⠀⠀⠀⣀⣴⣾⡿⠀⠀⠀⠀⢻⣿⣿⣇
//                      ⣿⣿⣿⠀⠀⠀⠀⠀⠈⠉⠛⠛⠂⡀⠤⠤⢄⠘⠛⠋⠉⠀⠀⠀⠀⠀⠘⣿⣿⣿
//                      ⢿⣿⣿⠀⠀⢀⣀⠀⠀⠀⠀⡐⠁⢀⣀⣀⡀⠑⢄⠀⠀⠀⠀⣀⠀⠀⠠⣿⣿⡏
//                      ⠸⣿⣿⡄⠀⠀⠀⠈⠐⢄⡜⠀⠀⢿⣿⣿⡇⠀⠀⢢⠄⠊⠁⠀⠀⠀⢸⣿⣿⠃
//                      ⠀⢻⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⠏⠀
//                      ⠀⠀⠻⣿⣿⣷⣄⡀⠀⠀⠀⠀⢻⠉⠻⠋⠉⠏⠀⠀⠀⠀⢀⣤⣾⣿⣿⠏⠀⠀
//                      ⠀⠀⠀⠙⢿⣿⣿⣿⣶⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣾⣿⣿⣿⡿⠁⠀⠀⠀
//                      ⠀⠀⠀⠀⠀⠙⠻⣿⣿⣿⣿⣿⣶⣶⣶⣶⣶⣾⣿⣿⣿⣿⣿⠟⠉⠀⠀⠀⠀⠀
//                      ⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⠻⠿⢿⣿⣿⣿⣿⡿⠿⠟⠛⠉⠀⠀⠀⠀⠀⠀⠀⠀
//
//                                  developed by:
//                    ░█████╗░██╗░░██╗██████╗░███████╗░█████╗░
//                    ██╔══██╗██║░██╔╝╚════██╗██╔════╝██╔═══╝░
//                    ██║░░╚═╝█████═╝░░░███╔═╝██████╗░██████╗░
//                    ██║░░██╗██╔═██╗░██╔══╝░░╚════██╗██╔══██╗
//                    ╚█████╔╝██║░╚██╗███████╗██████╔╝╚█████╔╝
//                    ░╚════╝░╚═╝░░╚═╝╚══════╝╚═════╝░░╚════╝░
//
//                                  [ SOCIALS ]
//                      -----------------------------------
//                      | Discord: Trillion Shib           |
//                      | https://trillionshibburn.com     |
//                      | https://twitter.com/tshibburn    |
//                      -----------------------------------

pragma solidity ^0.8.17;

import "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol";
import "@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol";
import "@chainlink/contracts/src/v0.8/ConfirmedOwner.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

contract TSBGame01 is VRFConsumerBaseV2, ConfirmedOwner {
    using SafeMath for uint256;
    /* ===== CONSTANTS ===== */

    bytes32 public SHIB_Symbol = bytes32(bytes(('Shib')));

    /* ===== TOKEN SUPPORT ===== */
    mapping(address => mapping(bytes32 => uint256)) public accountBalances;
    mapping(bytes32 => address) public whitelistedTokens;

    /* ===== GENERAL GAME ===== */

    address payable public immutable burnerWallet;
    address payable public immutable adminWallet;
    address public shibaInuToken;
    address[] public players;       // Array of players in each game
    address[] public winners;
    mapping (uint => address payable) public winnerHistory; 

    uint256 totalNumPlayers;        // Global variable to track total number of players in this contract
    uint256 totalNumGames;          // Global variable to track total number of games played
    uint256 totalAmtPaidOut = 0;    // Global variable to track total amount paid out
    uint256 totalAmtBurned = 0;     // Global variable to track total amount burned
    uint256 totalAmtAdmin = 0;      // Global variable to track total amount sent to admin wallet         


    bool public gameStarted;        // state variable to determine when game/tourney has started
    bool gamePaused;        //state variable for play/pause games


    uint public entryfee;           // The entry fee for each game
    uint256 eachGameBalance;         // The balance of the individual game
    uint maxPlayers = 0;            // The max players for each game
    uint amtReward = 30;            // The amount in percent sent as reward 
    uint amtBurn = 60;              // The amount in percentage sent to burn wallet
    uint amtAdmin = 10;             // The amount in percentage sent to admin wallet
    uint numGamesInTourney = 1;     //The number of games in a tourney, or set of games
    uint numGamesforFundRelease = 1;//The cadence of fund release for admin/burn within tourney
    uint public gameId;             // The game ID within the tourney - this is incremented + 1 within each tourney
    uint public tourneyID;          // The tourney ID - this is incremented + 1 with each set of games
    address public recentWinner;    // The address of the most recent winner


    /* ===== CHAINLINK VRF ===== */
    mapping(uint256 => RequestStatus)   //Chainlink VRF Que
    public s_requests; /* requestId --> requestStatus */
    VRFCoordinatorV2Interface COORDINATOR;
    // Your subscription ID for LINK.
    uint64 s_subscriptionId;
    // past requests Id.
    uint256[] public requestIds;        //Chainlink VRF 
    uint256 public lastRequestId;
    bytes32 immutable keyHash;
    address public immutable linkToken;
    uint32 callbackGasLimit = 150000;
    uint16 requestConfirmations = 3;
    uint32 numWords = 1;
    uint public randomWordsNum;

    struct RequestStatus {
        bool fulfilled; // whether the request has been successfully fulfilled
        bool exists; // whether a requestId exists
        uint256[] randomWords;
    }

    /* ===== EVENTS ===== */

    event RequestSent(uint256 requestId, uint32 numWords);
    event RequestFulfilled(uint256 requestId, uint256[] randomWords);
    event Transfer(address indexed _from, address indexed _to, uint256 _amount);
    event GameStarted(uint gameId, uint tourneyID, uint maxPlayers, uint entryfee);
    event PlayerJoined(uint gameId, address player);
    event GameEnded(uint gameId, address winner);
    event TourneyEnded(uint tourneyID, address winner);
    
    constructor(
        uint64 subscriptionId,
        address _linkToken, 
        //bytes32 _erc20WhiteListSymbol,
        address _erc20WhiteListAddress,
        address payable _burnerWallet,
        address payable _adminWallet
        )
            VRFConsumerBaseV2(0x2Ca8E0C643bDe4C2E08ab1fA0da3401AdAD7734D)
            ConfirmedOwner(msg.sender)
        {
            COORDINATOR = VRFCoordinatorV2Interface(
                0x2Ca8E0C643bDe4C2E08ab1fA0da3401AdAD7734D
            );
            s_subscriptionId = subscriptionId;
            keyHash = 0x79d3d8832d904592c0bf9818b621522c988bb8b0c05cdc3b15aea1b6e8db0c15; // we alread set this
            linkToken = _linkToken;
            shibaInuToken = _erc20WhiteListAddress;
            gameStarted = false;
            burnerWallet = _burnerWallet;  // Replace with the actual burner wallet address;
            adminWallet = _adminWallet;  // Replace with the actual admin wallet address;
            gamePaused = false;
    }

    receive() external payable {}

    /* ===== GAME STATS ===== */

    function getPlayersCount() public view returns (uint256){
        return players.length;

    }
    function getMaxPlayersCount() public view returns (uint256){
        return maxPlayers;
    }

    function getTotalPlayers() public view returns (uint256){
        return totalNumPlayers;
    }

    function getTotalGames() public view returns (uint256){
        return totalNumGames;
    }

    function getGamesInTourney() public view returns (uint){
        return numGamesInTourney;
    }

    function getGameState() public view returns (bool) {
        return gamePaused;
    }

    function getPlayers() public view returns (address[] memory) {
        return players;
    }

    function getamountReward() public view returns (uint) {
        return amtReward;       // returns the current game reward percentage
    }

    function getamountBurn() public view returns (uint) {
        return amtBurn;

    }
    function getamountAdmin() public view returns (uint) {
        return amtAdmin;
    }


    // returns the total amount paid out over the life of the contract
    function getTotalAmountPaidOut() public view returns (uint256) {
        return totalAmtPaidOut;
    }

    // returns the total amount burned over the life of the contract
    function getTotalAmountBurned() public view returns (uint256) {
        return totalAmtBurned;
    }

        // returns the total amount sent to the admin wallet
    function getTotalAmountAdmin() public view returns (uint256) {
        return totalAmtAdmin;
    }


    // returns the balance of the contract (eth)
    function getContractBalance() public view returns (uint256) {
        return address(this).balance;
    }

    // returns the balance of the contract (SHIB)
    function getContractBalanceSHIB() public view returns (uint256) {
        return IERC20(whitelistedTokens[SHIB_Symbol]).balanceOf(address(this));
    }

    /* ===== GAME FUNCTIONS ===== */


    function pauseplayGame() public onlyOwner returns (bool)
    {
        gamePaused = !gamePaused;
        return gamePaused;
    }

    function startGame(uint _maxPlayers, uint _entryfee) public onlyOwner {
        require(!gameStarted, "The Game has started");
        
        players = new address[](0);
        maxPlayers = _maxPlayers;
        gameStarted = true;
        entryfee = _entryfee; // assumes entry fee is in whole eth numbers
        gameId += 1;
        tourneyID += 1;
        eachGameBalance = 0;

        emit GameStarted(gameId, tourneyID, maxPlayers, entryfee);
    }

    function startGameSHIB(uint _maxPlayers, uint _entryfee, uint _amtReward, uint _amtBurn, uint _amtAdmin, uint _gamespertourney ) public onlyOwner {
        require(!gameStarted, "The Game has started");
            
        
        players = new address[](0);
        numGamesInTourney = _gamespertourney;
        maxPlayers = _maxPlayers;
        amtReward = _amtReward;
        amtBurn = _amtBurn;
        amtAdmin = _amtAdmin;
        gameStarted = true;
        entryfee = _entryfee; // assumes entry fee is in millions of SHIB
        gameId += 1;
        tourneyID += 1;
        eachGameBalance = 0;
        emit GameStarted(gameId, tourneyID, maxPlayers, entryfee);
    }


    function restartGameSHIB() internal {

        require(gameStarted, "The Game has not started");
        players = new address[](0);
        gameStarted = true;
        gameId += 1;
        eachGameBalance = 0;
        emit GameStarted(gameId, tourneyID, maxPlayers, entryfee);

    }

    function endGame() internal {
        require(gameStarted, "The Game has not started");
        require(!gamePaused, "The Game is paused right now");
        gameId = 0;
        eachGameBalance = 0;
        gameStarted = false;
        emit GameEnded(gameId, recentWinner);
    }


    function joinGameSHIB(uint256 amount, bytes32 symbol) public payable     {
        require(gameStarted, "The Game has not kicked off");
        require(players.length < maxPlayers, "The Game is Filled Up!");
        require(!gamePaused, "The Game is paused right now");
        require(amount == entryfee,"The amount should be equal to the entry fee");

        IERC20(whitelistedTokens[symbol]).transferFrom(msg.sender, address(this), amount);
        eachGameBalance += amount;
        players.push(msg.sender);
        emit PlayerJoined(gameId, msg.sender);

            if (players.length == maxPlayers) {
            getRandomWinner();
            
            // Calculate splits
            uint256 rewardAmount = eachGameBalance.mul(amtReward).div(100);
            uint256 burnerAmount = eachGameBalance.mul(amtBurn).div(100);
            uint256 adminAmount = eachGameBalance.mul(amtAdmin).div(100);
            burnerAmount = eachGameBalance - rewardAmount - adminAmount;
            // reset the state of the contract
            totalNumGames += 1;
            totalNumPlayers += players.length;
            players = new address payable[](0);

            // Transfer to the admin wallet
            _transferSHIB(SHIB_Symbol, payable(adminWallet), adminAmount);
            totalAmtAdmin += adminAmount;
            // Transfer to the winner wallet
            _transferSHIB(SHIB_Symbol, payable(recentWinner), rewardAmount);
            totalAmtPaidOut += rewardAmount;
            // Transfer to the burner wallet
            _transferSHIB(SHIB_Symbol, payable(burnerWallet), burnerAmount);
            totalAmtBurned += burnerAmount;

            // Restart the game if max games hasn't been reached yet.
            if (gameId == numGamesInTourney) {
                endGame();
            }
            else {
                restartGameSHIB();
            }

        }

    }

    function joinGame() public payable {
        require(gameStarted, "The Game has not kicked off");
        require(players.length < maxPlayers, "The Game is Filled Up!");
        require(!gamePaused, "The Game is paused right now");
        require(msg.value == entryfee,"The amount should be equal to the entry fee");

        players.push(msg.sender);
        emit PlayerJoined(gameId, msg.sender);

        if (players.length == maxPlayers) {
            getRandomWinner();

                // Calculate splits
            uint256 balance = address(this).balance;
            uint256 rewardAmount = balance.mul(30).div(100);
            uint256 burnerAmount = balance.mul(60).div(100);
            uint256 adminAmount = balance.mul(10).div(100);

            // sendAdmin(commissionAmount);
            //sendBurn(burnAmount);
            //payWinner(winnerAmount, recentWinner);

            // reset the state of the contract
            totalNumGames += 1;
            totalNumPlayers += players.length;
            players = new address payable[](0);


            // Transfer to the burner walleta
            _transfer(payable(burnerWallet), burnerAmount);

            // Transfer to the admin wallet
            _transfer(payable(adminWallet), adminAmount);

            // Transfer to the reward wallet
            _transfer(payable(recentWinner), rewardAmount);

            endGame();
                
        }
    }

    function getRandomWinner() internal returns (address) {
        
        // Semi Random function here
        uint256 winnerIndex = uint(keccak256(abi.encodePacked(msg.sender, block.timestamp))) % players.length;
        // Pick the first player for now
            winnerIndex = 0;
        
        // Next Two Lines for Random Winner
        //uint256 requestId = requestRandomWords();
        //uint256 winnerIndex = randomWordsNum % players.length;

        recentWinner = players[winnerIndex];
        // (bool success, ) = recentWinner.call{value: winnerAmount}("");
        //require(success, "Could not send ether");
        //gameStarted = false;
        emit GameEnded(gameId, recentWinner);
        return recentWinner;
    }

    /* ===== TOKEN FUNCTIONS ===== */
    function whitelistToken(bytes32 symbol, address tokenAddress) onlyOwner external {
        //require(onlyOwner, 'This function is not public');
        whitelistedTokens[symbol] = tokenAddress;
    }

    function depositTokens(uint256 amount, bytes32 symbol) external {
        accountBalances[msg.sender][symbol] += amount;
        IERC20(shibaInuToken).transferFrom(msg.sender, address(this), amount);
    }

    function _transfer(address payable to, uint256 amount) internal {
        require(address(this).balance >= amount, "Insufficient balance");
        to.transfer(amount);
        emit Transfer(address(this), to, amount);
    }


    function _transferSHIB(bytes32 symbol,  address payable to, uint256 amount) internal {
        //(bool success, ) = to.call{value: amount}("");
        IERC20(whitelistedTokens[symbol]).transfer(to, amount);
        //ERC20(whitelistedTokens[symbol]).transfer(to, amount);
        //_transferrequire(success, "Transfer failed");
        emit Transfer(address(this), to, amount);
    }


    /* ===== CHAINLINK VRF FUNCTIONS ===== */

    function requestRandomWords() public  returns (uint256 requestId) {
        requestId = COORDINATOR.requestRandomWords(
            keyHash,
            s_subscriptionId,
            requestConfirmations,
            callbackGasLimit,
            numWords
        );
        s_requests[requestId] = RequestStatus({
            randomWords: new uint256[](0),
            exists: true,
            fulfilled: false
        });
        requestIds.push(requestId);
        lastRequestId = requestId;
        emit RequestSent(requestId, numWords);
        return requestId; // requestID is a uint.
    }

    function fulfillRandomWords(
        uint256 _requestId,
        uint256[] memory _randomWords
    ) internal override {
        require(s_requests[_requestId].exists, "request not found");
        s_requests[_requestId].fulfilled = true;
        s_requests[_requestId].randomWords = _randomWords;
        randomWordsNum = _randomWords[0]; // Set array-index to variable, easier to play with
        emit RequestFulfilled(_requestId, _randomWords);
    }

    // to check the request status of random number call.
    function getRequestStatus(
        uint256 _requestId
    ) external view returns (bool fulfilled, uint256[] memory randomWords) {
        require(s_requests[_requestId].exists, "request not found");
        RequestStatus memory request = s_requests[_requestId];
        return (request.fulfilled, request.randomWords);
    }
}